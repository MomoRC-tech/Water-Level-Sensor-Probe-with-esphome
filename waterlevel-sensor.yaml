,substitutions:
  devicename: welllevel
  friendly_name: "WellLevel"
  sensor_update_sec: "0.5"   # Measurement interval in seconds (2 Hz)

esphome:
  name: ${devicename}
  comment: "Well water level with TL-136 (4–20 mA, 0–5 m), ESP8266 D1 Mini, relay, deep sleep"
  on_boot:
    priority: -100
    then:
      # Respect Stay Awake switch at boot
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - deep_sleep.prevent: main_deep_sleep
          else:
            - deep_sleep.allow: main_deep_sleep

      # Initialize gate
      - lambda: |-
          id(publish_ready) = false;

      # Small initial delay
      - delay: 2s

      # Wait until API is available so we can use HA helper entities
      - wait_until:
          condition:
            api.connected

      - logger.log:
          level: DEBUG
          format: "Boot: API connected, StayAwake=%s, HA_prevent_deep_sleep=%s"
          args:
            - 'id(deep_sleep_disable).state ? "ON" : "OFF"'
            - 'id(ha_prevent_deep_sleep).state ? "ON" : "OFF"'

      - delay: 1s

      # Start the first standardized measurement cycle
      - script.execute: run_measurement_cycle

  on_shutdown:
    then:
      # Before sleeping switch relay OFF (unpower sensor safely)
      - switch.turn_off: sensor_power

web_server:
  port: 80

esp8266:
  board: d1_mini

logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret ap_password
  manual_ip:
    static_ip: 192.168.0.91   # same as you used in use_address
    gateway: 192.168.0.1       # your Fritz!Box IP
    subnet: 255.255.255.0
  min_auth_mode: WPA2

captive_portal:

api:

ota:
  platform: esphome
  password: !secret ota_password

deep_sleep:
  id: main_deep_sleep
  # run_duration/sleep_duration are controlled dynamically via deep_sleep.enter
  # based on cfg_sleep_duration_min.

# ============================================================
# GLOBALS & SCRIPTS FOR STANDARDIZED MEASUREMENT CYCLE
# ============================================================

globals:
  - id: publish_ready
    type: bool
    restore_value: false
    initial_value: 'false'

  # NEW: step-response debug state
  - id: step_debug_active
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: step_debug_last_voltage
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_last_depth_unf
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_last_depth_f
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_filtered_current
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_filter_initialized
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: step_debug_sample_index
    type: int
    restore_value: false
    initial_value: '0'

  - id: step_debug_log
    type: std::string
    restore_value: false
    initial_value: ""

  # simple analysis: deviation filtered – unfiltered after 1/2/3 s
  - id: step_debug_dev1
    type: float
    restore_value: false
    initial_value: 'NAN'
  - id: step_debug_dev2
    type: float
    restore_value: false
    initial_value: 'NAN'
  - id: step_debug_dev3
    type: float
    restore_value: false
    initial_value: 'NAN'

  # ### step-response metrics
  - id: step_debug_d0_f
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_step_amp_m
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_t90_idx
    type: int
    restore_value: false
    initial_value: '-1'

  - id: step_debug_tsettle_idx
    type: int
    restore_value: false
    initial_value: '-1'

  - id: step_debug_settle_counter
    type: int
    restore_value: false
    initial_value: '0'

  # Welford stats for noise on plateau
  - id: step_debug_noise_unf_n
    type: float
    restore_value: false
    initial_value: '0'
  - id: step_debug_noise_unf_mean
    type: float
    restore_value: false
    initial_value: '0'
  - id: step_debug_noise_unf_M2
    type: float
    restore_value: false
    initial_value: '0'

  - id: step_debug_noise_f_n
    type: float
    restore_value: false
    initial_value: '0'
  - id: step_debug_noise_f_mean
    type: float
    restore_value: false
    initial_value: '0'
  - id: step_debug_noise_f_M2
    type: float
    restore_value: false
    initial_value: '0'

  # scalar metrics for debug sensors
  - id: step_debug_t90_s
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_tsettle_s
    type: float
    restore_value: false
    initial_value: 'NAN'

  - id: step_debug_noise_factor
    type: float
    restore_value: false
    initial_value: 'NAN'


script:
  ##################################################################################################
  # One standardized measurement sequence, which is bypassed when step-response debug mode is active:
  # - make sure relay is ON
  # - warm-up
  # - 10 samples @ 2 Hz (every 500 ms), updating the full chain
  # - publish once to HA
  # - call check_deep_sleep() to decide next step
  - id: run_measurement_cycle
    then:
      - if:
          condition:
            lambda: 'return id(step_debug_active);'
          then:
            - logger.log:
                level: DEBUG
                format: "run_measurement_cycle: skipped (step-response debug active)"
          else:
            - logger.log:
                level: DEBUG
                format: "run_measurement_cycle: start"

            # 1) Ensure sensor is powered
            - switch.turn_on: sensor_power

            # 2) Warm-up time for sensor & filters
            - delay: 3s

            # 3) Clear publish gate while we collect samples
            - lambda: |-
                id(publish_ready) = false;

            # 4) 10 samples @ 2 Hz (500 ms) – only what is needed for math
            - repeat:
                count: 10
                then:
                  - lambda: |-
                      id(shunt_adc_raw).update();
                      id(loop_current_raw).update();
                      id(loop_current_filtered).update();
                  - delay: 500ms

            # 5) Internal derivations (not exposed directly)
            - component.update: sensor_column_filtered_m
            - component.update: well_depth_raw

            # 6) Now allow publishing and push all visible entities once
            - lambda: |-
                id(publish_ready) = true;

            # Diagnostics visible in HA
            - component.update: shunt_voltage
            - component.update: loop_current_raw
            - component.update: loop_current_filtered

            # Final “user” depth entities
            - component.update: water_depth_from_head
            - component.update: water_depth_from_surface
            - component.update: water_over_pump1
            - component.update: water_over_pump2

            # Give API a moment to send values
            - delay: 1s

            # 7) Decide if we go to sleep or schedule another measurement
            - script.execute: check_deep_sleep


  ###########################################################
  # Decide whether to deep sleep or stay awake and re-measure
  - id: check_deep_sleep
    then:
      - logger.log:
          level: DEBUG
          format: "check_deep_sleep: StayAwake=%s, HA_prevent_deep_sleep=%s"
          args:
            - 'id(deep_sleep_disable).state ? "ON" : "OFF"'
            - 'id(ha_prevent_deep_sleep).state ? "ON" : "OFF"'

      # If either flag is ON -> stay awake, schedule next cycle
      - if:
          condition:
            or:
              - switch.is_on: deep_sleep_disable
              - binary_sensor.is_on: ha_prevent_deep_sleep
          then:
            - logger.log:
                level: DEBUG
                format: "check_deep_sleep: deep sleep prevented -> scheduling next measurement cycle"

            # Wait some time before next measurement (tunable)
            - delay: 10s

            # Start the next cycle
            - script.execute: run_measurement_cycle

          else:
            # Deep sleep allowed: turn relay OFF and then sleep
            - logger.log:
                level: DEBUG
                format: "check_deep_sleep: all flags OFF -> going to deep sleep soon"

            # 10 seconds "grace period" before sleep
            - delay: 10s
            - switch.turn_off: sensor_power
            - delay: 2s

            - deep_sleep.enter:
                id: main_deep_sleep
                sleep_duration: !lambda |-
                  float mins = id(cfg_sleep_duration_min).state;
                  if (isnan(mins) || mins < 1.0f) mins = 10.0f;
                  return (uint32_t) (mins * 60.0f * 1000.0f);

  ##################################
  # Auto-off for "Stay Awake" switch
  - id: auto_off_stay_awake
    then:
      - delay: 10min
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - logger.log: "Auto-off Stay Awake after 10 min"
            - switch.turn_off: deep_sleep_disable

  #################################
  # run and calculate step response
  - id: run_step_response_debug
    then:
      - logger.log:
          level: DEBUG
          format: "Step-response debug: starting"

      # make sure sensor is powered during debug
      - switch.turn_on: sensor_power

      # mark debug active and init state
      - lambda: |-
          id(step_debug_active) = true;
          id(step_debug_sample_index) = 0;
          id(step_debug_log).clear();   // will later hold a compact metrics JSON
          id(step_debug_filter_initialized) = false;
          id(step_debug_dev1) = NAN;
          id(step_debug_dev2) = NAN;
          id(step_debug_dev3) = NAN;

          // metrics init
          id(step_debug_d0_f) = NAN;
          id(step_debug_step_amp_m) = 2.0f;      // 2 m water-level drop -> depth +2 m
          id(step_debug_t90_idx) = -1;
          id(step_debug_tsettle_idx) = -1;
          id(step_debug_settle_counter) = 0;
          id(step_debug_noise_unf_n) = 0.0f;
          id(step_debug_noise_unf_mean) = 0.0f;
          id(step_debug_noise_unf_M2) = 0.0f;
          id(step_debug_noise_f_n) = 0.0f;
          id(step_debug_noise_f_mean) = 0.0f;
          id(step_debug_noise_f_M2) = 0.0f;
          id(step_debug_t90_s) = NAN;
          id(step_debug_tsettle_s) = NAN;
          id(step_debug_noise_factor) = NAN;


      - deep_sleep.prevent: main_deep_sleep

      #######################################
      # Phase 1: 3.0 V for 2s (4 samples)
      #######################################
      - repeat:
          count: 4
          then:
            - lambda: |-
                const float dt = ${sensor_update_sec};   // 0.5 s
                const float voltage = 3.0f;
                float r = id(cfg_shunt_resistance_ohm).state;
                if (isnan(r) || r < 1.0f) r = 165.0f;

                float current = (voltage / r) * 1000.0f;  // mA

                // --- compute unfiltered depth from current (same calibration as well_depth_raw) ---
                float i1 = id(cfg_cal1_current_mA).state;
                float i2 = id(cfg_cal2_current_mA).state;
                float d1 = id(cfg_cal1_depth_m).state;
                float d2 = id(cfg_cal2_depth_m).state;
                float span = id(cfg_sensor_span_m).state;
                float d_sensor = id(cfg_head_to_sensor).state;
                if (isnan(span) || span <= 0.0f) span = 5.0f;

                bool calib_valid = true;
                if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
                if (fabs(i2 - i1) < 0.1f) calib_valid = false;
                if (fabs(d2 - d1) < 0.01f) calib_valid = false;

                float depth_unf;
                if (calib_valid) {
                  float m = (d2 - d1) / (i2 - i1);
                  float b = d1 - m * i1;
                  depth_unf = m * current + b;
                } else {
                  const float I_MIN = 4.0f;
                  const float I_MAX = 20.0f;
                  float level = (current - I_MIN) / (I_MAX - I_MIN) * span;
                  if (level < 0.0f) level = 0.0f;
                  if (level > span) level = span;
                  depth_unf = d_sensor - level;
                }

                // --- EMA filter on current (debug-only state, same as loop_current_filtered) ---
                float window_s = id(cfg_filter_window_s).state;
                if (isnan(window_s) || window_s < 1.0f) window_s = 1.0f;
                float alpha = dt / window_s;
                if (alpha > 1.0f) alpha = 1.0f;

                if (!id(step_debug_filter_initialized)) {
                  id(step_debug_filtered_current) = current;
                  id(step_debug_filter_initialized) = true;
                } else {
                  id(step_debug_filtered_current) =
                    id(step_debug_filtered_current) +
                    alpha * (current - id(step_debug_filtered_current));
                }

                // depth from filtered current (same calibration as above)
                float depth_f;
                float i = id(step_debug_filtered_current);
                if (calib_valid) {
                  float m = (d2 - d1) / (i2 - i1);
                  float b = d1 - m * i1;
                  depth_f = m * i + b;
                } else {
                  const float I_MIN = 4.0f;
                  const float I_MAX = 20.0f;
                  float level = (i - I_MIN) / (I_MAX - I_MIN) * span;
                  if (level < 0.0f) level = 0.0f;
                  if (level > span) level = span;
                  depth_f = d_sensor - level;
                }

                // store last sample for sensors
                id(step_debug_last_voltage)    = voltage;
                id(step_debug_last_depth_unf)  = depth_unf;
                id(step_debug_last_depth_f)    = depth_f;

                int idx = id(step_debug_sample_index);
                float t = idx * dt;

                // NDJSON-style per-sample log line
                ESP_LOGD("step_debug",
                         "{\"t\":%.2f,\"phase\":1,\"v\":%.3f,\"d_unf\":%.3f,\"d_f\":%.3f}",
                         t, voltage, depth_unf, depth_f);

                id(step_debug_sample_index)++;


            - component.update: step_response_voltage_in
            - component.update: step_response_depth_unfiltered
            - component.update: step_response_depth_filtered
            - delay: 500ms

      # after phase 1 (3.0 V) – use last filtered depth as baseline d0
      - lambda: |-
          id(step_debug_d0_f) = id(step_debug_last_depth_f);


      #######################################
      # Phase 2: step = 2 m drop for 10 s (20 samples)
      #######################################
      - repeat:
          count: 20
          then:
            - lambda: |-
                const float dt = ${sensor_update_sec};   // 0.5 s

                // base from phase 1: 3.0 V -> current
                float r = id(cfg_shunt_resistance_ohm).state;
                if (isnan(r) || r < 1.0f) r = 165.0f;
                float base_current = (3.0f / r) * 1000.0f; // mA

                // slope m [m per mA] from calibration, default to 0.25 if invalid
                float i1 = id(cfg_cal1_current_mA).state;
                float i2 = id(cfg_cal2_current_mA).state;
                float d1 = id(cfg_cal1_depth_m).state;
                float d2 = id(cfg_cal2_depth_m).state;
                float span = id(cfg_sensor_span_m).state;
                float d_sensor = id(cfg_head_to_sensor).state;
                if (isnan(span) || span <= 0.0f) span = 5.0f;

                bool calib_valid = true;
                if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
                if (fabs(i2 - i1) < 0.1f) calib_valid = false;
                if (fabs(d2 - d1) < 0.01f) calib_valid = false;

                float m_depth_per_mA = 0.25f;
                if (calib_valid) {
                  m_depth_per_mA = (d2 - d1) / (i2 - i1);
                  if (fabs(m_depth_per_mA) < 1e-3f) m_depth_per_mA = 0.25f;
                }

                // 2 m water-level drop:
                // depth below wellhead increases by +2 m (surface goes 2 m deeper)
                // => Δd = +2 m, so ΔI = Δd / m_depth_per_mA
                float step_depth_delta_m = id(step_debug_step_amp_m);  // +2.0f
                float delta_I = step_depth_delta_m / m_depth_per_mA;
                float current = base_current + delta_I;

                // convert back to voltage used for debug entity
                float voltage = (current / 1000.0f) * r;

                // depth_unf and depth_f same as above
                float depth_unf;
                if (calib_valid) {
                  float m = (d2 - d1) / (i2 - i1);
                  float b = d1 - m * i1;
                  depth_unf = m * current + b;
                } else {
                  const float I_MIN = 4.0f;
                  const float I_MAX = 20.0f;
                  float level = (current - I_MIN) / (I_MAX - I_MIN) * span;
                  if (level < 0.0f) level = 0.0f;
                  if (level > span) level = span;
                  depth_unf = d_sensor - level;
                }

                float window_s = id(cfg_filter_window_s).state;
                if (isnan(window_s) || window_s < 1.0f) window_s = 1.0f;
                float alpha = dt / window_s;
                if (alpha > 1.0f) alpha = 1.0f;

                id(step_debug_filtered_current) =
                  id(step_debug_filtered_current) +
                  alpha * (current - id(step_debug_filtered_current));

                float depth_f;
                float i = id(step_debug_filtered_current);
                if (calib_valid) {
                  float m = (d2 - d1) / (i2 - i1);
                  float b = d1 - m * i1;
                  depth_f = m * i + b;
                } else {
                  const float I_MIN = 4.0f;
                  const float I_MAX = 20.0f;
                  float level = (i - I_MIN) / (I_MAX - I_MIN) * span;
                  if (level < 0.0f) level = 0.0f;
                  if (level > span) level = span;
                  depth_f = d_sensor - level;
                }

                id(step_debug_last_voltage)    = voltage;
                id(step_debug_last_depth_unf)  = depth_unf;
                id(step_debug_last_depth_f)    = depth_f;

                int idx = id(step_debug_sample_index);

                // --- metrics: t90 and t_settle ---
                float d0   = id(step_debug_d0_f);
                float A    = id(step_debug_step_amp_m);   // e.g. +2.0 m (depth increase)
                float absA = fabsf(A);

                if (!isnan(d0) && absA > 0.0f) {
                  // time to 90% of step
                  if (id(step_debug_t90_idx) < 0) {
                    if (fabsf(depth_f - d0) >= 0.9f * absA) {
                      id(step_debug_t90_idx) = idx;
                    }
                  }

                  // settling time: within 2% band for 4 consecutive samples
                  float d_inf_target = d0 + A;  // final value
                  if (fabsf(depth_f - d_inf_target) <= 0.02f * absA) {
                    id(step_debug_settle_counter)++;
                    if (id(step_debug_tsettle_idx) < 0 &&
                        id(step_debug_settle_counter) >= 4) {
                      id(step_debug_tsettle_idx) = idx;
                    }
                  } else {
                    id(step_debug_settle_counter) = 0;
                  }
                }

                // --- metrics: noise reduction on plateau using Welford ---
                // treat last half of step phase as "plateau"
                const int plateau_start = 4 + 10;  // idx >= 14 (2 s pre + 5 s transient)
                if (idx >= plateau_start) {
                  // unfiltered
                  float n = id(step_debug_noise_unf_n) + 1.0f;
                  float delta = depth_unf - id(step_debug_noise_unf_mean);
                  float mean = id(step_debug_noise_unf_mean) + delta / n;
                  float delta2 = depth_unf - mean;
                  float M2 = id(step_debug_noise_unf_M2) + delta * delta2;
                  id(step_debug_noise_unf_n) = n;
                  id(step_debug_noise_unf_mean) = mean;
                  id(step_debug_noise_unf_M2) = M2;

                  // filtered
                  n = id(step_debug_noise_f_n) + 1.0f;
                  delta = depth_f - id(step_debug_noise_f_mean);
                  mean = id(step_debug_noise_f_mean) + delta / n;
                  delta2 = depth_f - mean;
                  M2 = id(step_debug_noise_f_M2) + delta * delta2;
                  id(step_debug_noise_f_n) = n;
                  id(step_debug_noise_f_mean) = mean;
                  id(step_debug_noise_f_M2) = M2;
                }

                // capture deviations at 1/2/3 s after step start
                // step starts after 4 samples (2 s) -> indices 4, then +2,4,6 => 6,8,10
                if (idx == 6) id(step_debug_dev1) = depth_f - depth_unf;
                if (idx == 8) id(step_debug_dev2) = depth_f - depth_unf;
                if (idx == 10) id(step_debug_dev3) = depth_f - depth_unf;

                float t = idx * dt;
                ESP_LOGD("step_debug",
                         "{\"t\":%.2f,\"phase\":2,\"v\":%.3f,\"d_unf\":%.3f,\"d_f\":%.3f}",
                         t, voltage, depth_unf, depth_f);

                id(step_debug_sample_index)++;


            - component.update: step_response_voltage_in
            - component.update: step_response_depth_unfiltered
            - component.update: step_response_depth_filtered
            - delay: 500ms

      - lambda: |-
          const float dt = ${sensor_update_sec};

          // derive scalar metrics into globals
          if (id(step_debug_t90_idx) >= 0) {
            id(step_debug_t90_s) = id(step_debug_t90_idx) * dt;
          } else {
            id(step_debug_t90_s) = NAN;
          }

          if (id(step_debug_tsettle_idx) >= 0) {
            id(step_debug_tsettle_s) = id(step_debug_tsettle_idx) * dt;
          } else {
            id(step_debug_tsettle_s) = NAN;
          }

          if (id(step_debug_noise_unf_n) > 1.0f &&
              id(step_debug_noise_f_n) > 1.0f) {
            float var_unf = id(step_debug_noise_unf_M2) /
                            (id(step_debug_noise_unf_n) - 1.0f);
            float var_f   = id(step_debug_noise_f_M2) /
                            (id(step_debug_noise_f_n) - 1.0f);
            if (var_unf > 0.0f && var_f > 0.0f) {
              id(step_debug_noise_factor) = sqrtf(var_unf / var_f);
            } else {
              id(step_debug_noise_factor) = NAN;
            }
          } else {
            id(step_debug_noise_factor) = NAN;
          }

          // build compact metrics JSON into step_debug_log
          char buf[200];
          snprintf(buf, sizeof(buf),
                   "{\"t90_s\":%.2f,\"t_settle_s\":%.2f,"
                   "\"noise_reduction\":%.2f,"
                   "\"dev1_m\":%.3f,\"dev2_m\":%.3f,\"dev3_m\":%.3f}",
                   id(step_debug_t90_s),
                   id(step_debug_tsettle_s),
                   id(step_debug_noise_factor),
                   id(step_debug_dev1),
                   id(step_debug_dev2),
                   id(step_debug_dev3));
          id(step_debug_log) = buf;

          ESP_LOGD("step_debug", "Step-response metrics: %s",
                   id(step_debug_log).c_str());

      # publish compact metrics JSON to text entity
      - text_sensor.template.publish:
          id: step_response_report
          state: !lambda 'return id(step_debug_log);'

      - logger.log:
          level: DEBUG
          format: "Step-response debug finished"

      - lambda: |-
          id(step_debug_active) = false;

      - deep_sleep.allow: main_deep_sleep

      # resume normal operation
      - script.execute: run_measurement_cycle


# ============================================================
# RELAY: High-side switch of 5 V feed to 24 V boost (controls sensor power)
# ============================================================

output:
  - platform: gpio
    pin: D5              # D5 (GPIO14) -> relay IN
    id: sensor_power_out
    inverted: false

switch:
  - platform: output
    name: "Sensor Power"
    id: sensor_power
    output: sensor_power_out
    restore_mode: ALWAYS_ON
    entity_category: diagnostic

  - platform: template
    name: "Stay Awake"
    id: deep_sleep_disable
    icon: "mdi:power-sleep-off"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_stay_awake
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

button:
  - platform: template
    name: "Trigger Step-response"
    id: trigger_step_response
    entity_category: diagnostic
    on_press:
      - script.execute: run_step_response_debug

text_sensor:
  - platform: template
    id: step_response_report
    name: "Step-response Report"
    entity_category: diagnostic
    update_interval: never

# ============================================================
# 1) CONFIGURATION ENTITIES
# ============================================================

number:
  # Sleep duration between measurements (minutes)
  - platform: template
    name: "CFG Sleep Duration"
    id: cfg_sleep_duration_min
    unit_of_measurement: "min"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 1.0
    max_value: 120.0
    step: 1.0
    mode: BOX

  # Shunt resistance (Ohm) used for loop current conversion
  - platform: template
    name: "CFG Shunt Resistance"
    id: cfg_shunt_resistance_ohm
    unit_of_measurement: "Ω"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 150.0
    min_value: 10.0
    max_value: 1000.0
    step: 1.0
    mode: BOX

  # Sensor span (m) – default 5 m
  - platform: template
    name: "CFG Sensor Span"
    id: cfg_sensor_span_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 1.0
    max_value: 10.0
    step: 0.1
    mode: BOX

  # Distance well head to sensor position
  - platform: template
    name: "CFG Well Head to Sensor"
    id: cfg_head_to_sensor
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 20.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 1
  - platform: template
    name: "CFG Well Head to Pump 1"
    id: cfg_head_to_pump1
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 6.4
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 2
  - platform: template
    name: "CFG Well Head to Pump 2"
    id: cfg_head_to_pump2
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.5
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Filter window for exponential moving average (seconds)
  - platform: template
    name: "CFG Filter Window Sensor Signal"
    id: cfg_filter_window_s
    unit_of_measurement: "s"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 3.0
    min_value: 1.0
    max_value: 10.0
    step: 0.5
    mode: BOX

  # Calibration point 1: depth at well head and corresponding loop current
  - platform: template
    name: "CFG Cal1 Depth from Head"
    id: cfg_cal1_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 20.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Cal1 Loop Current"
    id: cfg_cal1_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.35
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  # Calibration point 2: depth and loop current at second reference point
  - platform: template
    name: "CFG Cal2 Depth from Head"
    id: cfg_cal2_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0.0
    min_value: 0.0
    max_value: 20.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Cal2 Loop Current"
    id: cfg_cal2_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Surface to Well Head"
    id: cfg_surface_to_well_head
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0.95
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    mode: BOX

  # Dry-current threshold band (mA) – below this, we consider "waterlevel below minimum"
  - platform: template
    name: "CFG Dry Current Band"
    id: cfg_dry_current_band_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 3.8
    min_value: 0.0
    max_value: 10.0
    step: 0.01
    mode: BOX

# ============================================================
# 2) SENSING & CALCULATIONS
# ============================================================

sensor:
  # 2.1 Raw ADC at A0 (internal 0..1 V range)
  - platform: adc
    pin: A0
    id: shunt_adc_raw
    name: "ADC Internal"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    entity_category: diagnostic
    internal: true
    # External hardware: mandatory 1 kΩ series resistor + optional RC filter for protection

  # 2.2 Actual shunt voltage (0..~3.2 V at A0 on D1 mini)
  - platform: template
    id: shunt_voltage
    name: "Shunt Voltage Raw"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    entity_category: diagnostic
    filters:
      - lambda: |-
          // Only publish once per cycle when publish_ready is true
          if (!id(publish_ready)) return {};
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      return u_adc * 3.2f;

  # 2.3 Raw loop current (mA) from shunt voltage
  - platform: template
    id: loop_current_raw
    name: "Loop Current Raw"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    entity_category: diagnostic
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      float u = u_adc * 3.2f;
      float r = id(cfg_shunt_resistance_ohm).state;
      if (isnan(r) || r < 1.0f) return NAN;
      float i_mA = (u / r) * 1000.0f;
      if (i_mA < 3.9f) return NAN;
      return i_mA;

  # 2.4 Filtered loop current with warmup phase (EMA)
  - platform: template
    id: loop_current_filtered
    name: "Loop Current"
    unit_of_measurement: "mA"
    device_class: current
    state_class: measurement
    accuracy_decimals: 3
    entity_category: diagnostic
    icon: "mdi:current-ac"
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) return NAN;
      float raw = id(loop_current_raw).state;
      if (isnan(raw)) return NAN;
      float window_s = id(cfg_filter_window_s).state;
      if (isnan(window_s) || window_s < 1.0f) window_s = 1.0f;
      const float dt = ${sensor_update_sec};
      float alpha = dt / window_s;
      if (alpha > 1.0f) alpha = 1.0f;
      static float avg = NAN;
      static int warmup_count = 0;
      const int WARMUP_SAMPLES = 3;
      if (isnan(avg)) avg = raw;
      else           avg = avg + alpha * (raw - avg);
      warmup_count++;
      if (warmup_count <= WARMUP_SAMPLES) return NAN;
      return avg;

  # 2.5 Filtered sensor column (0..5 m above sensor) – diagnostic only
  - platform: template
    id: sensor_column_filtered_m
    name: "Sensor Column"
    unit_of_measurement: "m"
    accuracy_decimals: 2
    icon: "mdi:waves"
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      const float I_MIN = 4.0f;
      const float I_MAX = 20.0f;
      float range_m = id(cfg_sensor_span_m).state; // configured sensor span
      if (isnan(range_m) || range_m < 0.5f) range_m = 5.0f;

      float i_mA = id(loop_current_filtered).state;
      if (isnan(i_mA)) return NAN;
      // Invalid if below 4 mA threshold (already handled in raw, redundant safety)
      if (i_mA < 3.9f) return NAN;
      if (i_mA < 0.5f || i_mA > 25.0f) return NAN;

      float level = (i_mA - I_MIN) / (I_MAX - I_MIN) * range_m;
      if (level < 0.0f) level = 0.0f;
      if (level > range_m) level = range_m;
      return level;

  # 2.6 Calibrated water depth from well head (m)
  # 2.6a Depth Below Head (raw, but based on EMA-filtered loop current)
  # Uses filtered loop current for stability; applies two-point calibration when valid,
  # otherwise falls back to span curve.
  - platform: template
    id: well_depth_raw
    name: "Depth Below Head (Raw)"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 2
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      float i = id(loop_current_filtered).state;
      if (isnan(i)) return NAN;

      float i1 = id(cfg_cal1_current_mA).state;
      float i2 = id(cfg_cal2_current_mA).state;
      float d1 = id(cfg_cal1_depth_m).state;
      float d2 = id(cfg_cal2_depth_m).state;
      float span = id(cfg_sensor_span_m).state;
      float d_sensor = id(cfg_head_to_sensor).state;

      bool calib_valid = true;
      if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
      if (fabs(i2 - i1) < 0.1f) calib_valid = false;
      if (fabs(d2 - d1) < 0.01f) calib_valid = false;

      // Enforce calibration depths within measurable range: [head_to_sensor - span, head_to_sensor]
      if (isnan(span) || span <= 0.0f) span = 5.0f;
      if (isnan(d_sensor)) calib_valid = false;
      if (calib_valid) {
        float d_min = d_sensor - span;
        float d_max = d_sensor;
        if (d1 < d_min || d1 > d_max || d2 < d_min || d2 > d_max) {
          calib_valid = false;
        }
      }

      if (!calib_valid) {
        // Fallback to span curve (0 m => 4 mA, span m => 20 mA)
        const float I_MIN = 4.0f;
        const float I_MAX = 20.0f;
        if (i < 3.9f) return NAN;
        if (i < 0.5f || i > 25.0f) return NAN;
        float level = (i - I_MIN) / (I_MAX - I_MIN) * span;
        if (level < 0.0f) level = 0.0f;
        if (level > span) level = span;
        return d_sensor - level;
      }

      // Two-point calibration: d = m * i + b
      float m = (d2 - d1) / (i2 - i1);
      float b = d1 - m * i1;
      float d = m * i + b;

      // Clamp to [d_sensor - span, d_sensor]
      float d_min = d_sensor - span;
      float d_max = d_sensor;
      if (d < d_min) d = d_min;
      if (d > d_max) d = d_max;
      return d;

  # 2.6b Published depth below head (filtered)
  - platform: template
    id: water_depth_from_head
    name: "Depth Below Head"
    icon: "mdi:arrow-down-bold"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;  // Gate until single publish moment
      return id(well_depth_raw).state;

  # 2.7 Water depth below surface (m), based on EMA-filtered head depth
  - platform: template
    id: water_depth_from_surface
    name: "Depth Below Surface"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;

      float depth_head      = id(water_depth_from_head).state;
      float surface_to_head = id(cfg_surface_to_well_head).state;
      if (isnan(depth_head) || isnan(surface_to_head)) {
        return NAN;
      }
      return depth_head + surface_to_head;


  # 2.8 Water height above pump 1 (m), positive = pump submerged
  - platform: template
    id: water_over_pump1
    name: "Water Over Pump 1"
    icon: "mdi:waves-arrow-up"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump1 = id(cfg_head_to_pump1).state;
      if (isnan(depth_head) || isnan(d_pump1)) {
        return NAN;
      }
      return d_pump1 - depth_head;

  # 2.9 Water height above pump 2 (m), positive = pump submerged
  - platform: template
    id: water_over_pump2
    name: "Water Over Pump 2"
    icon: "mdi:waves-arrow-up"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump2 = id(cfg_head_to_pump2).state;
      if (isnan(depth_head) || isnan(d_pump2)) {
        return NAN;
      }
      return d_pump2 - depth_head;

  # 2.10 step response entitites
  - platform: template
    id: step_response_voltage_in
    name: "Step-response Voltage In"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_last_voltage);

  - platform: template
    id: step_response_depth_unfiltered
    name: "Step-response Depth Unfiltered"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_last_depth_unf);

  - platform: template
    id: step_response_depth_filtered
    name: "Step-response Depth Filtered"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_last_depth_f);

  # 2.11 Step-response metrics as sensors for HA charts
  - platform: template
    id: step_response_t90_s
    name: "Step-response t90"
    unit_of_measurement: "s"
    accuracy_decimals: 2
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_t90_s);

  - platform: template
    id: step_response_t_settle_s
    name: "Step-response t_settle"
    unit_of_measurement: "s"
    accuracy_decimals: 2
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_tsettle_s);

  - platform: template
    id: step_response_noise_reduction
    name: "Step-response Noise Reduction"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_noise_factor);

  - platform: template
    id: step_response_dev1
    name: "Step-response Deviation 1s"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_dev1);

  - platform: template
    id: step_response_dev2
    name: "Step-response Deviation 2s"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_dev2);

  - platform: template
    id: step_response_dev3
    name: "Step-response Deviation 3s"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    entity_category: diagnostic
    lambda: |-
      return id(step_debug_dev3);

binary_sensor:
  # Mirror HA input_boolean.prevent_deep_sleep
  - platform: homeassistant
    id: ha_prevent_deep_sleep
    entity_id: input_boolean.prevent_deep_sleep
    internal: true

  - platform: template
    id: waterlevel_below_minimum
    name: "Waterlevel Below Minimum"
    device_class: problem
    lambda: |-
      // Only decide at the final publish moment of a measurement cycle
      if (!id(publish_ready)) return {};
      float i = id(loop_current_filtered).state;
      float th = id(cfg_dry_current_band_mA).state;
      if (isnan(i) || isnan(th)) return {};
      return i < th;

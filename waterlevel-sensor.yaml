substitutions:
  devicename: welllevel
  friendly_name: "WellLevel"
  sensor_update_sec: "5.0"   # Measurement interval in seconds

esphome:
  name: ${devicename}
  comment: "Well water level with TL-136 (4–20 mA, 0–5 m), ESP8266 D1 Mini, relay, deep sleep"
  on_boot:
    priority: -100
    then:
      # Allow or prevent deep sleep based on HA switch state
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - deep_sleep.prevent: main_deep_sleep
          else:
            - deep_sleep.allow: main_deep_sleep
      # Initialize high-rate sampling cycle
      - lambda: |-
          id(publish_ready) = false;
          id(high_rate_done) = false;
          id(sampling_start_ms) = millis();
      # Stabilization delay before starting high-rate sampling
      - delay: 2s
      - script.execute: start_high_rate_sampling

  on_shutdown:
    then:
      # Before sleeping switch relay OFF (unpower sensor safely)
      - switch.turn_off: sensor_power

web_server:
  port: 80

esp8266:
  board: d1_mini

logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret ap_password
  manual_ip:
    static_ip: 192.168.0.91   # same as you used in use_address
    gateway: 192.168.0.1       # your Fritz!Box IP
    subnet: 255.255.255.0

captive_portal:

api:

ota:
  platform: esphome
  password: !secret ota_password

deep_sleep:
  id: main_deep_sleep
  # run_duration/sleep_duration are controlled dynamically via deep_sleep.enter
  # based on cfg_sleep_duration_min.

# ============================================================
# GLOBALS & SCRIPTS FOR HIGH-RATE SAMPLING / SINGLE PUBLISH
# ============================================================

globals:
  - id: publish_ready
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: high_rate_done
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: sampling_start_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'

script:
  - id: start_high_rate_sampling
    then:
      - lambda: |-
          id(sampling_start_ms) = millis();
          id(high_rate_done) = false;
          id(publish_ready) = false;

  - id: complete_cycle_and_sleep
    then:
      # 1) Gate opens: sensors may now publish
      - lambda: |-
          id(publish_ready) = true;

      # 2) Force one final update of the key sensors (single publish moment)
      - component.update: loop_current_filtered 
      - component.update: water_depth_from_head
      - component.update: water_depth_from_surface
      - component.update: water_over_pump1
      - component.update: water_over_pump2

      # Optional small delay to ensure the values get sent out via API
      - delay: 500ms

      # 3) If deep sleep is allowed → power down sensor, short grace time, then sleep
      #    Otherwise: stay awake and keep sensor powered for continuous updates
      - if:
          condition:
            and:
              - switch.is_off: deep_sleep_disable
              - switch.is_off: burst_mode
              - binary_sensor.is_off: ha_prevent_deep_sleep
          then:
            # Deep sleep path
            - switch.turn_off: sensor_power      # cut sensor power only when sleeping
            - delay: 10s                         # stay awake for another 10s
            - deep_sleep.enter:
                id: main_deep_sleep
                sleep_duration: !lambda |-
                  // cfg_sleep_duration_min is in minutes → convert to ms
                  float mins = id(cfg_sleep_duration_min).state;
                  if (isnan(mins) || mins < 1.0f) mins = 10.0f;  // safety default
                  return (uint32_t) (mins * 60.0f * 1000.0f);
          else:
            # Stay-awake path
            - logger.log: "Deep sleep prevented (Stay Awake, Burst Mode or HA helper active) - periodic updates every 10s"
            - switch.turn_on: sensor_power       # ensure sensor stays powered

  - id: auto_off_stay_awake
    then:
      - delay: 10min
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - logger.log: "Auto-off Stay Awake after 10 min"
            - switch.turn_off: deep_sleep_disable

  - id: auto_off_burst_mode
    then:
      - delay: 10min
      - if:
          condition:
            switch.is_on: burst_mode
          then:
            - logger.log: "Auto-off Burst Mode after 10 min"
            - switch.turn_off: burst_mode

# Interval timers
interval:
  # High-rate sampling during the first ~5s
  - interval: 500ms
    then:
      - lambda: |-
          if (id(high_rate_done)) return; // Already finished
          uint32_t elapsed = millis() - id(sampling_start_ms);
          if (elapsed <= 5000) {
            // Force updates of raw chain to accelerate existing filters.
            id(shunt_adc_raw).update();
            id(shunt_voltage).update();
            id(loop_current_raw).update();
            id(loop_current_filtered).update();
            id(well_depth_raw).update();
          } else {
            id(high_rate_done) = true;
            // Run completion script (single publish + optional sleep / stay-awake)
            id(complete_cycle_and_sleep).execute();
          }

  # Periodic updates every 10s when deep sleep is prevented
  - interval: 10s
    then:
      - if:
          condition:
            or:
              - switch.is_on: deep_sleep_disable
              - switch.is_on: burst_mode
              - binary_sensor.is_on: ha_prevent_deep_sleep
          then:
            # Update the measurement chain
            - lambda: |-
                id(shunt_adc_raw).update();
                id(shunt_voltage).update();
                id(loop_current_raw).update();
                id(loop_current_filtered).update();
                id(well_depth_raw).update();
            # And push the publishable entities (publish_ready is already true)
            - component.update: water_depth_from_head
            - component.update: water_depth_from_surface
            - component.update: water_over_pump1
            - component.update: water_over_pump2

# ============================================================
# RELAY: High-side switch of 5 V feed to 24 V boost (controls sensor power)
# ============================================================

output:
  - platform: gpio
    pin: D5              # D5 (GPIO14) -> relay IN
    id: sensor_power_out
    inverted: false

switch:
  - platform: output
    name: "Sensor Power"
    id: sensor_power
    output: sensor_power_out
    restore_mode: ALWAYS_ON
    entity_category: diagnostic

  - platform: template
    name: "Stay Awake"
    id: deep_sleep_disable
    icon: "mdi:power-sleep-off"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_stay_awake
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

  - platform: template
    name: "Burst Mode"
    id: burst_mode
    icon: "mdi:chart-bubble"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_burst_mode
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

# ============================================================
# 1) CONFIGURATION VALUES (adjustable via Home Assistant)
# ============================================================

number:
  # Distance from surface (ground level) down to well head (positive value means well head is below surface)
  - platform: template
    name: "CFG Surface to Well Head"
    id: cfg_surface_to_well_head
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0.95
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    mode: BOX

  # Distance well head to sensor position
  - platform: template
    name: "CFG Well Head to Sensor"
    id: cfg_head_to_sensor
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 20.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 1
  - platform: template
    name: "CFG Well Head to Pump 1"
    id: cfg_head_to_pump1
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 6.4
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 2
  - platform: template
    name: "CFG Well Head to Pump 2"
    id: cfg_head_to_pump2
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.5
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Filter window for exponential moving average (seconds)
  - platform: template
    name: "CFG Filter Window Sensor Signal"
    id: cfg_filter_window_s
    unit_of_measurement: "s"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 2.0
    max_value: 60.0
    step: 1.0
    mode: BOX

  # Calibration point 1: loop current (mA)
  - platform: template
    name: "CFG Calibration Point 1 Current"
    id: cfg_cal1_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.35
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  # Calibration point 1: depth from well head (m)
  - platform: template
    name: "CFG Calibration Point 1 Depth"
    id: cfg_cal1_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  # Calibration point 2: loop current (mA)
  - platform: template
    name: "CFG Calibration Point 2 Current"
    id: cfg_cal2_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  # Calibration point 2: depth from well head (m)
  - platform: template
    name: "CFG Calibration Point 2 Depth"
    id: cfg_cal2_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    # For a 5 m span sensor with sensor mounted 5 m below well head:
    #   4 mA (dry)  -> depth = 5.0 m (head_to_sensor)
    #   20 mA (full)-> depth = 0.0 m (head_to_sensor - span)
    # Adjust after setting head_to_sensor or cfg_sensor_span_m.
    initial_value: 0.0
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

  # Shunt resistance value (Ohms)
  - platform: template
    name: "CFG Shunt Resistance"
    id: cfg_shunt_resistance_ohm
    unit_of_measurement: "Ω"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 150.0
    min_value: 50.0
    max_value: 200.0
    step: 1.0
    mode: BOX

  # Sensor full measurable water column span (m) above sensor (factory = 5 m for TL-136)
  - platform: template
    name: "CFG Sensor Span"
    id: cfg_sensor_span_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 1.0
    max_value: 50.0
    step: 0.1
    mode: BOX

  # Sleep duration (minutes) for deep sleep phase
  - platform: template
    name: "CFG Sleep Duration"
    id: cfg_sleep_duration_min
    unit_of_measurement: "min"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 1.0
    max_value: 60.0
    step: 1.0
    mode: BOX

  # Dry detection current threshold (mA). If loop current drops below this value, well considered dry.
  - platform: template
    name: "CFG Dry Current Threshold"
    id: cfg_dry_current_band_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 0.0
    max_value: 25.0
    step: 0.01
    mode: BOX

# ============================================================
# 2) SENSING & CALCULATIONS
# ============================================================

sensor:
  # 2.1 Raw ADC at A0 (internal 0..1 V range)
  - platform: adc
    pin: A0
    id: shunt_adc_raw
    name: "ADC Internal"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    # External hardware: mandatory 1 kΩ series resistor + optional RC filter for protection

  # 2.2 Actual shunt voltage (0..~3.2 V at A0 on D1 mini)
  - platform: template
    id: shunt_voltage
    name: "Shunt Voltage Raw"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    lambda: |-
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      // D1 mini: ADC 0..1 V corresponds to ~0..3.2 V at A0
      return u_adc * 3.2f;

  # 2.3 Raw loop current (mA) from shunt voltage
  - platform: template
    id: loop_current_raw
    name: "Loop Current Raw"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;  // Sensor off
      }
      float u = id(shunt_voltage).state;            // Volts
      float r = id(cfg_shunt_resistance_ohm).state; // Ohms
      if (isnan(u) || isnan(r) || r < 1.0f) {
        return NAN;
      }
      float i_mA = (u / r) * 1000.0f;
      // Treat currents clearly below nominal 4 mA as invalid (open loop / defect)
      // Use a small margin to avoid noise misclassification.
      if (i_mA < 3.9f) return NAN;
      return i_mA;

  # 2.4 Filtered loop current with warmup phase (EMA)
  - platform: template
    id: loop_current_filtered
    name: "Loop Current"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    icon: "mdi:current-ac"
    filters:
      - lambda: |-
          // Do not publish NaN values – keep last good value in HA
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }

      float raw = id(loop_current_raw).state;
      if (isnan(raw)) {
        return NAN;
      }

      float window_s = id(cfg_filter_window_s).state;
      if (isnan(window_s) || window_s < 1.0f) {
        window_s = 1.0f;
      }

      const float dt = ${sensor_update_sec};
      float alpha = dt / window_s;
      if (alpha > 1.0f) alpha = 1.0f;

      static float avg = NAN;
      static int warmup_count = 0;
      const int WARMUP_SAMPLES = 3;  // Number of cycles for warmup

      if (isnan(avg)) {
        avg = raw;              // Initialization
      } else {
        avg = avg + alpha * (raw - avg);
      }

      warmup_count++;

      // During warmup we still compute, but filter above will drop NaN
      if (warmup_count <= WARMUP_SAMPLES) {
        return NAN;
      }

      return avg;


  # 2.5 Filtered sensor column (0..5 m above sensor) – diagnostic only
  - platform: template
    id: sensor_column_filtered_m
    name: "Sensor Column"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    icon: "mdi:waves"
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      const float I_MIN = 4.0f;
      const float I_MAX = 20.0f;
      float range_m = id(cfg_sensor_span_m).state; // configured sensor span
      if (isnan(range_m) || range_m < 0.5f) range_m = 5.0f;

      float i_mA = id(loop_current_filtered).state;
      if (isnan(i_mA)) return NAN;
      // Invalid if below 4 mA threshold (already handled in raw, redundant safety)
      if (i_mA < 3.9f) return NAN;
      if (i_mA < 0.5f || i_mA > 25.0f) return NAN;

      float level = (i_mA - I_MIN) / (I_MAX - I_MIN) * range_m;
      if (level < 0.0f) level = 0.0f;
      if (level > range_m) level = range_m;
      return level;

  # 2.6 Calibrated water depth from well head (m)
  # 2.6a Depth Below Head (raw, but based on EMA-filtered loop current)
  # Uses filtered loop current for stability; applies two-point calibration when valid,
  # otherwise falls back to span curve.
  - platform: template
    id: well_depth_raw
    name: "Depth Below Head (Raw)"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    entity_category: diagnostic
    internal: true
    update_interval: ${sensor_update_sec}s
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      float i = id(loop_current_filtered).state;  // EMA-filtered current as measurement
      if (isnan(i)) return NAN;

      float i1 = id(cfg_cal1_current_mA).state;
      float i2 = id(cfg_cal2_current_mA).state;
      float d1 = id(cfg_cal1_depth_m).state;
      float d2 = id(cfg_cal2_depth_m).state;
      float span = id(cfg_sensor_span_m).state;
      float d_sensor = id(cfg_head_to_sensor).state;

      bool calib_valid = true;
      if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
      if (fabs(i2 - i1) < 0.1f) calib_valid = false;
      if (fabs(d2 - d1) < 0.01f) calib_valid = false;

      // Enforce calibration depths within measurable range: [head_to_sensor - span, head_to_sensor]
      if (isnan(span) || span <= 0.0f) span = 5.0f;
      if (isnan(d_sensor)) calib_valid = false;
      if (calib_valid) {
        float min_depth = d_sensor - span;
        float max_depth = d_sensor;
        const float eps = 0.001f;
        if (d1 < (min_depth - eps) || d1 > (max_depth + eps)) calib_valid = false;
        if (d2 < (min_depth - eps) || d2 > (max_depth + eps)) calib_valid = false;
      }

      float depth;
      if (calib_valid) {
        float t = (i - i1) / (i2 - i1);
        depth = d1 + t * (d2 - d1);
      } else {
        // Fallback: theoretical sensor curve (0..sensor span column above sensor)
        float h_over_sensor = id(sensor_column_filtered_m).state;
        if (isnan(h_over_sensor)) return NAN;
        depth = d_sensor - h_over_sensor;
      }

      return depth;

  # 2.6b Published Depth Below Head: expose EMA-based raw depth once per cycle
  - platform: template
    id: water_depth_from_head
    name: "Depth Below Head"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;  // Gate until single publish moment
      return id(well_depth_raw).state;

  # 2.7 Water depth below surface (m), based on EMA-filtered head depth
  - platform: template
    id: water_depth_from_surface
    name: "Depth Below Surface"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;          // m below well head (EMA-based)
      float surface_to_head = id(cfg_surface_to_well_head).state;  // m (surface down to well head)

      if (isnan(depth_head) || isnan(surface_to_head)) {
        return NAN;
      }

      // Depth below surface = depth below head + head depth below surface
      float depth_from_surface = depth_head + surface_to_head;
      return depth_from_surface;

  # 2.8 Water height above pump 1 (m), positive = pump submerged
  - platform: template
    id: water_over_pump1
    name: "Over Pump 1"
    icon: "mdi:pump"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump1 = id(cfg_head_to_pump1).state;
      if (isnan(depth_head) || isnan(d_pump1)) {
        return NAN;
      }
      return d_pump1 - depth_head;

  # 2.9 Water height above pump 2 (m), positive = pump submerged
  - platform: template
    id: water_over_pump2
    name: "Over Pump 2"
    icon: "mdi:pump"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump2 = id(cfg_head_to_pump2).state;
      if (isnan(depth_head) || isnan(d_pump2)) {
        return NAN;
      }
      return d_pump2 - depth_head;

# ============================================================
# 3) DRY / MINIMUM WATERLEVEL DETECTION + HA PREVENT DEEP SLEEP
# ============================================================

binary_sensor:
  # Mirror HA input_boolean.prevent_deep_sleep
  - platform: homeassistant
    id: ha_prevent_deep_sleep
    entity_id: input_boolean.prevent_deep_sleep
    internal: true

  - platform: template
    id: waterlevel_below_minimum
    name: "Waterlevel Below Minimum"
    device_class: problem
    lambda: |-
      // Only decide at the final publish moment of a measurement cycle
      if (!id(publish_ready)) return {};
      float i = id(loop_current_filtered).state;
      float th = id(cfg_dry_current_band_mA).state;
      if (isnan(i) || isnan(th)) return {};
      return i < th;

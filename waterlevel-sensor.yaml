substitutions:
  devicename: welllevel
  friendly_name: "WellLevel"
  sensor_update_sec: "0.5"   # Measurement interval in seconds (2 Hz)

esphome:
  name: ${devicename}
  comment: "Well water level with TL-136 (4–20 mA, 0–5 m), ESP8266 D1 Mini, relay, deep sleep"
  on_boot:
    priority: -100
    then:
      # Respect Stay Awake switch at boot
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - deep_sleep.prevent: main_deep_sleep
          else:
            - deep_sleep.allow: main_deep_sleep

      # Initialize gate
      - lambda: |-
          id(publish_ready) = false;

      # Small initial delay
      - delay: 2s

      # Wait until API is available so we can use HA helper entities
      - wait_until:
          condition:
            api.connected

      - logger.log:
          level: DEBUG
          format: "Boot: API connected, StayAwake=%s, HA_prevent_deep_sleep=%s"
          args:
            - 'id(deep_sleep_disable).state ? "ON" : "OFF"'
            - 'id(ha_prevent_deep_sleep).state ? "ON" : "OFF"'

      - delay: 1s

      # Start the first standardized measurement cycle
      - script.execute: run_measurement_cycle

  on_shutdown:
    then:
      # Before sleeping switch relay OFF (unpower sensor safely)
      - switch.turn_off: sensor_power

web_server:
  port: 80

esp8266:
  board: d1_mini

logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret ap_password
  manual_ip:
    static_ip: 192.168.0.91   # same as you used in use_address
    gateway: 192.168.0.1       # your Fritz!Box IP
    subnet: 255.255.255.0
  min_auth_mode: WPA2

captive_portal:

api:

ota:
  platform: esphome
  password: !secret ota_password

deep_sleep:
  id: main_deep_sleep
  # run_duration/sleep_duration are controlled dynamically via deep_sleep.enter
  # based on cfg_sleep_duration_min.

# ============================================================
# GLOBALS & SCRIPTS FOR STANDARDIZED MEASUREMENT CYCLE
# ============================================================

globals:
  - id: publish_ready
    type: bool
    restore_value: false
    initial_value: 'false'

script:
  # One standardized measurement sequence:
  # - make sure relay is ON
  # - warm-up
  # - 10 samples @ 2 Hz (every 500 ms), updating the full chain
  # - publish once to HA
  # - call check_deep_sleep() to decide next step
  - id: run_measurement_cycle
    then:
      - logger.log:
          level: DEBUG
          format: "run_measurement_cycle: start"

      # 1) Ensure sensor is powered
      - switch.turn_on: sensor_power

      # 2) Warm-up time for sensor & filters
      - delay: 3s

      # 3) Clear publish gate while we collect samples
      - lambda: |-
          id(publish_ready) = false;

      # 4) 10 samples @ 2 Hz (500 ms) – only what is needed for math
      - repeat:
          count: 10
          then:
            - lambda: |-
                id(shunt_adc_raw).update();
                id(loop_current_raw).update();
                id(loop_current_filtered).update();
            - delay: 500ms

      # 5) Internal derivations (not exposed to HA)
      - component.update: sensor_column_filtered_m
      - component.update: well_depth_raw

      # 6) Now allow publishing and push ALL visible entities once
      - lambda: |-
          id(publish_ready) = true;

      # Diagnostics visible in HA
      - component.update: shunt_voltage
      - component.update: loop_current_raw
      - component.update: loop_current_filtered

      # Final “user” depth entities
      - component.update: water_depth_from_head
      - component.update: water_depth_from_surface
      - component.update: water_over_pump1
      - component.update: water_over_pump2

      # Give API a moment to send values
      - delay: 1s

      # 7) Decide if we go to sleep or schedule another measurement
      - script.execute: check_deep_sleep



  # Decide whether to deep sleep or stay awake and re-measure
  - id: check_deep_sleep
    then:
      - logger.log:
          level: DEBUG
          format: "check_deep_sleep: StayAwake=%s, HA_prevent_deep_sleep=%s"
          args:
            - 'id(deep_sleep_disable).state ? "ON" : "OFF"'
            - 'id(ha_prevent_deep_sleep).state ? "ON" : "OFF"'

      # If either flag is ON -> stay awake, schedule next cycle
      - if:
          condition:
            or:
              - switch.is_on: deep_sleep_disable
              - binary_sensor.is_on: ha_prevent_deep_sleep
          then:
            - logger.log:
                level: DEBUG
                format: "check_deep_sleep: deep sleep prevented -> scheduling next measurement cycle"

            # Wait some time before next measurement (tunable)
            - delay: 10s

            # Start the next cycle
            - script.execute: run_measurement_cycle

          else:
            # Deep sleep allowed: turn relay OFF and then sleep
            - logger.log:
                level: DEBUG
                format: "check_deep_sleep: all flags OFF -> going to deep sleep soon"

            # 10 seconds "grace period" before sleep
            - delay: 10s
            - switch.turn_off: sensor_power
            - delay: 2s

            - deep_sleep.enter:
                id: main_deep_sleep
                sleep_duration: !lambda |-
                  float mins = id(cfg_sleep_duration_min).state;
                  if (isnan(mins) || mins < 1.0f) mins = 10.0f;
                  return (uint32_t) (mins * 60.0f * 1000.0f);


  # Auto-off for "Stay Awake" switch
  - id: auto_off_stay_awake
    then:
      - delay: 10min
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - logger.log: "Auto-off Stay Awake after 10 min"
            - switch.turn_off: deep_sleep_disable

# ============================================================
# RELAY: High-side switch of 5 V feed to 24 V boost (controls sensor power)
# ============================================================

output:
  - platform: gpio
    pin: D5              # D5 (GPIO14) -> relay IN
    id: sensor_power_out
    inverted: false

switch:
  - platform: output
    name: "Sensor Power"
    id: sensor_power
    output: sensor_power_out
    restore_mode: ALWAYS_ON
    entity_category: diagnostic

  - platform: template
    name: "Stay Awake"
    id: deep_sleep_disable
    icon: "mdi:power-sleep-off"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_stay_awake
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

# ============================================================
# 1) CONFIGURATION ENTITIES
# ============================================================

number:
  # Sleep duration between measurements (minutes)
  - platform: template
    name: "CFG Sleep Duration"
    id: cfg_sleep_duration_min
    unit_of_measurement: "min"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 1.0
    max_value: 120.0
    step: 1.0
    mode: BOX

  # Shunt resistance (Ohm) used for loop current conversion
  - platform: template
    name: "CFG Shunt Resistance"
    id: cfg_shunt_resistance_ohm
    unit_of_measurement: "Ω"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 165.0
    min_value: 10.0
    max_value: 1000.0
    step: 1.0
    mode: BOX

  # Sensor span (m) – default 5 m
  - platform: template
    name: "CFG Sensor Span"
    id: cfg_sensor_span_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 1.0
    max_value: 10.0
    step: 0.1
    mode: BOX

  # Distance well head to sensor position
  - platform: template
    name: "CFG Well Head to Sensor"
    id: cfg_head_to_sensor
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 20.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 1
  - platform: template
    name: "CFG Well Head to Pump 1"
    id: cfg_head_to_pump1
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 6.4
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Distance well head to pump 2
  - platform: template
    name: "CFG Well Head to Pump 2"
    id: cfg_head_to_pump2
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.5
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Filter window for exponential moving average (seconds)
  - platform: template
    name: "CFG Filter Window Sensor Signal"
    id: cfg_filter_window_s
    unit_of_measurement: "s"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 1.0
    max_value: 120.0
    step: 1.0
    mode: BOX

  # Calibration point 1: depth at well head and corresponding loop current
  - platform: template
    name: "CFG Cal1 Depth from Head"
    id: cfg_cal1_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 2.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Cal1 Loop Current"
    id: cfg_cal1_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 8.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  # Calibration point 2: depth and loop current at second reference point
  - platform: template
    name: "CFG Cal2 Depth from Head"
    id: cfg_cal2_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Cal2 Loop Current"
    id: cfg_cal2_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 16.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01
    mode: BOX

  - platform: template
    name: "CFG Surface to Well Head"
    id: cfg_surface_to_well_head
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0.95
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    mode: BOX

  # Dry-current threshold band (mA) – below this, we consider "waterlevel below minimum"
  - platform: template
    name: "CFG Dry Current Band"
    id: cfg_dry_current_band_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 3.8
    min_value: 0.0
    max_value: 10.0
    step: 0.01
    mode: BOX

# ============================================================
# 2) SENSING & CALCULATIONS
# ============================================================

sensor:
  # 2.1 Raw ADC at A0 (internal 0..1 V range)
  - platform: adc
    pin: A0
    id: shunt_adc_raw
    name: "ADC Internal"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    entity_category: diagnostic
    internal: true
    # External hardware: mandatory 1 kΩ series resistor + optional RC filter for protection

  # 2.2 Actual shunt voltage (0..~3.2 V at A0 on D1 mini)
  - platform: template
    id: shunt_voltage
    name: "Shunt Voltage Raw"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    entity_category: diagnostic
    filters:
      - lambda: |-
          // Only publish once per cycle when publish_ready is true
          if (!id(publish_ready)) return {};
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      return u_adc * 3.2f;

  # 2.3 Raw loop current (mA) from shunt voltage
  - platform: template
    id: loop_current_raw
    name: "Loop Current Raw"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    entity_category: diagnostic
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      float u = u_adc * 3.2f;
      float r = id(cfg_shunt_resistance_ohm).state;
      if (isnan(r) || r < 1.0f) return NAN;
      float i_mA = (u / r) * 1000.0f;
      if (i_mA < 3.9f) return NAN;
      return i_mA;

  # 2.4 Filtered loop current with warmup phase (EMA)
  - platform: template
    id: loop_current_filtered
    name: "Loop Current"
    unit_of_measurement: "mA"
    device_class: current
    state_class: measurement
    accuracy_decimals: 3
    entity_category: diagnostic
    icon: "mdi:current-ac"
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(sensor_power).state) return NAN;
      float raw = id(loop_current_raw).state;
      if (isnan(raw)) return NAN;
      float window_s = id(cfg_filter_window_s).state;
      if (isnan(window_s) || window_s < 1.0f) window_s = 1.0f;
      const float dt = ${sensor_update_sec};
      float alpha = dt / window_s;
      if (alpha > 1.0f) alpha = 1.0f;
      static float avg = NAN;
      static int warmup_count = 0;
      const int WARMUP_SAMPLES = 3;
      if (isnan(avg)) avg = raw;
      else           avg = avg + alpha * (raw - avg);
      warmup_count++;
      if (warmup_count <= WARMUP_SAMPLES) return NAN;
      return avg;

  # 2.5 Filtered sensor column (0..5 m above sensor) – diagnostic only
  - platform: template
    id: sensor_column_filtered_m
    name: "Sensor Column"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    icon: "mdi:waves"
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      const float I_MIN = 4.0f;
      const float I_MAX = 20.0f;
      float range_m = id(cfg_sensor_span_m).state; // configured sensor span
      if (isnan(range_m) || range_m < 0.5f) range_m = 5.0f;

      float i_mA = id(loop_current_filtered).state;
      if (isnan(i_mA)) return NAN;
      // Invalid if below 4 mA threshold (already handled in raw, redundant safety)
      if (i_mA < 3.9f) return NAN;
      if (i_mA < 0.5f || i_mA > 25.0f) return NAN;

      float level = (i_mA - I_MIN) / (I_MAX - I_MIN) * range_m;
      if (level < 0.0f) level = 0.0f;
      if (level > range_m) level = range_m;
      return level;

  # 2.6 Calibrated water depth from well head (m)
  # 2.6a Depth Below Head (raw, but based on EMA-filtered loop current)
  # Uses filtered loop current for stability; applies two-point calibration when valid,
  # otherwise falls back to span curve.
  - platform: template
    id: well_depth_raw
    name: "Depth Below Head (Raw)"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      float i = id(loop_current_filtered).state;
      if (isnan(i)) return NAN;

      float i1 = id(cfg_cal1_current_mA).state;
      float i2 = id(cfg_cal2_current_mA).state;
      float d1 = id(cfg_cal1_depth_m).state;
      float d2 = id(cfg_cal2_depth_m).state;
      float span = id(cfg_sensor_span_m).state;
      float d_sensor = id(cfg_head_to_sensor).state;

      bool calib_valid = true;
      if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
      if (fabs(i2 - i1) < 0.1f) calib_valid = false;
      if (fabs(d2 - d1) < 0.01f) calib_valid = false;

      // Enforce calibration depths within measurable range: [head_to_sensor - span, head_to_sensor]
      if (isnan(span) || span <= 0.0f) span = 5.0f;
      if (isnan(d_sensor)) calib_valid = false;
      if (calib_valid) {
        float d_min = d_sensor - span;
        float d_max = d_sensor;
        if (d1 < d_min || d1 > d_max || d2 < d_min || d2 > d_max) {
          calib_valid = false;
        }
      }

      if (!calib_valid) {
        // Fallback to span curve (0 m => 4 mA, span m => 20 mA)
        const float I_MIN = 4.0f;
        const float I_MAX = 20.0f;
        if (i < 3.9f) return NAN;
        if (i < 0.5f || i > 25.0f) return NAN;
        float level = (i - I_MIN) / (I_MAX - I_MIN) * span;
        if (level < 0.0f) level = 0.0f;
        if (level > span) level = span;
        return d_sensor - level;
      }

      // Two-point calibration: d = m * i + b
      float m = (d2 - d1) / (i2 - i1);
      float b = d1 - m * i1;
      float d = m * i + b;

      // Clamp to [d_sensor - span, d_sensor]
      float d_min = d_sensor - span;
      float d_max = d_sensor;
      if (d < d_min) d = d_min;
      if (d > d_max) d = d_max;
      return d;

  # 2.6b Published depth below head (filtered)
  - platform: template
    id: water_depth_from_head
    name: "Depth Below Head"
    icon: "mdi:arrow-down-bold"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;  // Gate until single publish moment
      return id(well_depth_raw).state;

  # 2.7 Water depth below surface (m), based on EMA-filtered head depth
  - platform: template
    id: water_depth_from_surface
    name: "Depth Below Surface"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;

      float depth_head      = id(water_depth_from_head).state;
      float surface_to_head = id(cfg_surface_to_well_head).state;
      if (isnan(depth_head) || isnan(surface_to_head)) {
        return NAN;
      }
      return depth_head + surface_to_head;


  # 2.8 Water height above pump 1 (m), positive = pump submerged
  - platform: template
    id: water_over_pump1
    name: "Water Over Pump 1"
    icon: "mdi:waves-arrow-up"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump1 = id(cfg_head_to_pump1).state;
      if (isnan(depth_head) || isnan(d_pump1)) {
        return NAN;
      }
      return d_pump1 - depth_head;

  # 2.9 Water height above pump 2 (m), positive = pump submerged
  - platform: template
    id: water_over_pump2
    name: "Water Over Pump 2"
    icon: "mdi:waves-arrow-up"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump2 = id(cfg_head_to_pump2).state;
      if (isnan(depth_head) || isnan(d_pump2)) {
        return NAN;
      }
      return d_pump2 - depth_head;

binary_sensor:
  # Mirror HA input_boolean.prevent_deep_sleep
  - platform: homeassistant
    id: ha_prevent_deep_sleep
    entity_id: input_boolean.prevent_deep_sleep
    internal: true

  - platform: template
    id: waterlevel_below_minimum
    name: "Waterlevel Below Minimum"
    device_class: problem
    lambda: |-
      // Only decide at the final publish moment of a measurement cycle
      if (!id(publish_ready)) return {};
      float i = id(loop_current_filtered).state;
      float th = id(cfg_dry_current_band_mA).state;
      if (isnan(i) || isnan(th)) return {};
      return i < th;

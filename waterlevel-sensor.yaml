substitutions:
  devicename: welllevel
  friendly_name: "WellLevel"
  sensor_update_sec: "5.0"   # Measurement interval in seconds

esphome:
  name: ${devicename}
  comment: "Well water level with TL-136 (4–20 mA, 0–5 m), ESP8266 D1 Mini, relay, deep sleep"
  on_boot:
    priority: -100
    then:
      # Allow or prevent deep sleep based on HA switch state
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - deep_sleep.prevent: main_deep_sleep
          else:
            - deep_sleep.allow: main_deep_sleep
      # Initialize high-rate sampling cycle
      - lambda: |-
          id(publish_ready) = false;
          id(high_rate_done) = false;
          id(sampling_start_ms) = millis();
      # Stabilization delay before starting high-rate sampling
      - delay: 2s
      - script.execute: start_high_rate_sampling

  on_shutdown:
    then:
      # Before sleeping switch relay OFF (unpower sensor safely)
      - switch.turn_off: sensor_power

esp8266:
  board: d1_mini

logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret ap_password

captive_portal:

api:

ota:
  platform: esphome
  password: !secret ota_password

deep_sleep:
  id: main_deep_sleep
  run_duration: 30s      # Active (measurement & filtering phase)
  sleep_duration: 10min  # Then enter deep sleep

# ============================================================
# GLOBALS & SCRIPTS FOR HIGH-RATE SAMPLING / SINGLE PUBLISH
# ============================================================

globals:
  - id: publish_ready
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: high_rate_done
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: sampling_start_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'

script:
  - id: start_high_rate_sampling
    then:
      - lambda: |-
          id(sampling_start_ms) = millis();
          id(high_rate_done) = false;
          id(publish_ready) = false;
  - id: complete_cycle_and_sleep
    then:
      - lambda: |-
          // Mark ready for single publish
          id(publish_ready) = true;
      # Enter deep sleep if not blocked by switches
      - if:
          condition:
            and:
              - switch.is_off: deep_sleep_disable
              - switch.is_off: burst_mode
          then:
            - deep_sleep.enter: main_deep_sleep
          else:
            - logger.log: "Deep sleep prevented (Stay Awake or Burst Mode active)"
  - id: auto_off_stay_awake
    then:
      - delay: 30min
      - if:
          condition:
            switch.is_on: deep_sleep_disable
          then:
            - logger.log: "Auto-off Stay Awake after 30 min"
            - switch.turn_off: deep_sleep_disable
  - id: auto_off_burst_mode
    then:
      - delay: 30min
      - if:
          condition:
            switch.is_on: burst_mode
          then:
            - logger.log: "Auto-off Burst Mode after 30 min"
            - switch.turn_off: burst_mode

# Interval for high-rate sampling (every 500 ms ~2 Hz during first 5 s)
interval:
  - interval: 500ms
    then:
      - lambda: |-
          if (id(high_rate_done)) return; // Already finished
          uint32_t elapsed = millis() - id(sampling_start_ms);
          if (elapsed <= 5000) {
            // Force updates of raw chain to accelerate existing filters.
            id(shunt_adc_raw).update();
            id(shunt_voltage).update();
            id(loop_current_raw).update();
            id(loop_current_filtered).update();
            id(well_depth_raw).update();
          } else {
            id(high_rate_done) = true;
            // Run completion script (single publish + optional sleep)
            id(complete_cycle_and_sleep).execute();
          }

# ============================================================
# RELAY: High-side switch of 5 V feed to 24 V boost (controls sensor power)
# ============================================================

output:
  - platform: gpio
    pin: D5              # D5 (GPIO14) -> relay IN
    id: sensor_power_out
    inverted: false

switch:
  - platform: output
    name: "Sensor Power"
    id: sensor_power
    output: sensor_power_out
    restore_mode: ALWAYS_ON
    entity_category: diagnostic

  - platform: template
    name: "Stay Awake"
    id: deep_sleep_disable
    icon: "mdi:power-sleep-off"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_stay_awake
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

  - platform: template
    name: "Burst Mode"
    id: burst_mode
    icon: "mdi:chart-bubble"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - deep_sleep.prevent: main_deep_sleep
      - script.execute: auto_off_burst_mode
    turn_off_action:
      - deep_sleep.allow: main_deep_sleep

# ============================================================
# 1) CONFIGURATION VALUES (adjustable via Home Assistant)
# ============================================================

number:
  # Distance from surface (ground level) down to well head (positive value means well head is below surface)
  - platform: template
    name: "CFG Surface to Well Head"
    id: cfg_surface_to_well_head
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 0.95
    min_value: 0.0
    max_value: 5.0
    step: 0.01

  # Distance well head to sensor position
  - platform: template
    name: "CFG Well Head to Sensor"
    id: cfg_head_to_sensor
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 20.0
    step: 0.01

  # Distance well head to pump 1
  - platform: template
    name: "CFG Well Head to Pump 1"
    id: cfg_head_to_pump1
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 6.4
    min_value: 0.0
    max_value: 50.0
    step: 0.01

  # Distance well head to pump 2
  - platform: template
    name: "CFG Well Head to Pump 2"
    id: cfg_head_to_pump2
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.5
    min_value: 0.0
    max_value: 50.0
    step: 0.01

  # Total well depth from head (informational currently)
  - platform: template
    name: "CFG Well Depth from Head"
    id: cfg_head_to_bottom
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 8.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01

  # Filter window for exponential moving average (seconds)
  - platform: template
    name: "CFG Filter Window Sensor Signal"
    id: cfg_filter_window_s
    unit_of_measurement: "s"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 60.0
    min_value: 5.0
    max_value: 600.0
    step: 5.0

  # Calibration point 1: loop current (mA)
  - platform: template
    name: "CFG Calibration Point 1 Current"
    id: cfg_cal1_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.35
    min_value: 0.0
    max_value: 30.0
    step: 0.01

  # Calibration point 1: depth from well head (m)
  - platform: template
    name: "CFG Calibration Point 1 Depth"
    id: cfg_cal1_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 4.80
    min_value: 0.0
    max_value: 50.0
    step: 0.01

  # Calibration point 2: loop current (mA)
  - platform: template
    name: "CFG Calibration Point 2 Current"
    id: cfg_cal2_current_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: 0.0
    max_value: 30.0
    step: 0.01

  # Calibration point 2: depth from well head (m)
  - platform: template
    name: "CFG Calibration Point 2 Depth"
    id: cfg_cal2_depth_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    # For a 5 m span sensor with sensor mounted 5 m below well head:
    #   4 mA (dry)  -> depth = 5.0 m (head_to_sensor)
    #   20 mA (full)-> depth = 0.0 m (head_to_sensor - span)
    # Adjust after setting head_to_sensor or cfg_sensor_span_m.
    initial_value: 0.0
    min_value: 0.0
    max_value: 50.0
    step: 0.01

  # Shunt resistance value (Ohms)
  - platform: template
    name: "CFG Shunt Resistance"
    id: cfg_shunt_resistance_ohm
    unit_of_measurement: "Ω"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 150.0
    min_value: 50.0
    max_value: 500.0
    step: 1.0

  # Sensor full measurable water column span (m) above sensor (factory = 5 m for TL-136)
  - platform: template
    name: "CFG Sensor Span"
    id: cfg_sensor_span_m
    unit_of_measurement: "m"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 1.0
    max_value: 50.0
    step: 0.1

  # Sleep duration (minutes) for deep sleep phase
  - platform: template
    name: "CFG Sleep Duration"
    id: cfg_sleep_duration_min
    unit_of_measurement: "min"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 10.0
    min_value: 1.0
    max_value: 180.0
    step: 1.0
  # Dry detection current threshold (mA). If loop current drops below this value, well considered dry.
  - platform: template
    name: "CFG Dry Current Threshold"
    id: cfg_dry_current_band_mA
    unit_of_measurement: "mA"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 5.0
    min_value: 0.0
    max_value: 25.0
    step: 0.01

# ============================================================
# 2) SENSING & CALCULATIONS
# ============================================================

sensor:
  # 2.1 Raw ADC at A0 (internal 0..1 V range)
  - platform: adc
    pin: A0
    id: shunt_adc_raw
    name: "ADC Internal"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    # External hardware: mandatory 1 kΩ series resistor + optional RC filter for protection

  # 2.2 Actual shunt voltage (0..~3.2 V at A0 on D1 mini)
  - platform: template
    id: shunt_voltage
    name: "Shunt Voltage Raw"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    lambda: |-
      float u_adc = id(shunt_adc_raw).state;
      if (isnan(u_adc)) return NAN;
      // D1 mini: ADC 0..1 V corresponds to ~0..3.2 V at A0
      return u_adc * 3.2f;

  # 2.3 Raw loop current (mA) from shunt voltage
  - platform: template
    id: loop_current_raw
    name: "Loop Current Raw"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;  // Sensor off
      }
      float u = id(shunt_voltage).state;            // Volts
      float r = id(cfg_shunt_resistance_ohm).state; // Ohms
      if (isnan(u) || isnan(r) || r < 1.0f) {
        return NAN;
      }
      float i_mA = (u / r) * 1000.0f;
      // Treat currents clearly below nominal 4 mA as invalid (open loop / defect)
      // Use a small margin to avoid noise misclassification.
      if (i_mA < 3.9f) return NAN;
      return i_mA;

  # 2.4 Filtered loop current with warmup phase
  - platform: template
    id: loop_current_filtered
    name: "Loop Current"
    unit_of_measurement: "mA"
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    icon: "mdi:current-ac"
    lambda: |-
      if (!id(sensor_power).state) {
        return NAN;
      }

      float raw = id(loop_current_raw).state;
      if (isnan(raw)) {
        return NAN;
      }

      float window_s = id(cfg_filter_window_s).state;
      if (isnan(window_s) || window_s < 1.0f) {
        window_s = 1.0f;
      }

      const float dt = ${sensor_update_sec};
      float alpha = dt / window_s;
      if (alpha > 1.0f) alpha = 1.0f;

      static float avg = NAN;
      static int warmup_count = 0;
      const int WARMUP_SAMPLES = 3;  // Number of cycles for warmup

      if (isnan(avg)) {
        avg = raw;              // Initialization
      } else {
        avg = avg + alpha * (raw - avg);
      }

      warmup_count++;

      // Suppress output during warmup phase
      if (warmup_count <= WARMUP_SAMPLES) {
        return NAN;
      }

      return avg;

  # 2.5 Filtered sensor column (0..5 m above sensor) – diagnostic only
  - platform: template
    id: sensor_column_filtered_m
    name: "Sensor Column"
    unit_of_measurement: "m"
    accuracy_decimals: 3
    icon: "mdi:waves"
    update_interval: ${sensor_update_sec}s
    entity_category: diagnostic
    internal: true
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      const float I_MIN = 4.0f;
      const float I_MAX = 20.0f;
      float range_m = id(cfg_sensor_span_m).state; // configured sensor span
      if (isnan(range_m) || range_m < 0.5f) range_m = 5.0f;

      float i_mA = id(loop_current_filtered).state;
      if (isnan(i_mA)) return NAN;
      // Invalid if below 4 mA threshold (already handled in raw, redundant safety)
      if (i_mA < 3.9f) return NAN;
      if (i_mA < 0.5f || i_mA > 25.0f) return NAN;

      float level = (i_mA - I_MIN) / (I_MAX - I_MIN) * range_m;
      if (level < 0.0f) level = 0.0f;
      if (level > range_m) level = range_m;
      return level;

  # 2.6 Calibrated water depth from well head (m)
  # 2.6a Depth Below Head (raw, unfiltered by Kalman) – keep calibration logic here
  # Uses filtered loop current for stability; applies two-point calibration when valid,
  # otherwise falls back to span curve. This serves as the input to the Kalman filter below.
  - platform: template
    id: well_depth_raw
    name: "Depth Below Head (Raw)"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    entity_category: diagnostic
    internal: true
    update_interval: ${sensor_update_sec}s
    lambda: |-
      if (!id(sensor_power).state) return NAN;

      float i = id(loop_current_filtered).state;  // use EMA-filtered current as measurement
      if (isnan(i)) return NAN;

      float i1 = id(cfg_cal1_current_mA).state;
      float i2 = id(cfg_cal2_current_mA).state;
      float d1 = id(cfg_cal1_depth_m).state;
      float d2 = id(cfg_cal2_depth_m).state;
      float span = id(cfg_sensor_span_m).state;
      float d_sensor = id(cfg_head_to_sensor).state;

      bool calib_valid = true;
      if (isnan(i1) || isnan(i2) || isnan(d1) || isnan(d2)) calib_valid = false;
      if (fabs(i2 - i1) < 0.1f) calib_valid = false;
      if (fabs(d2 - d1) < 0.01f) calib_valid = false;

      // Enforce calibration depths within measurable range: [head_to_sensor - span, head_to_sensor]
      if (isnan(span) || span <= 0.0f) span = 5.0f;
      if (isnan(d_sensor)) calib_valid = false;
      if (calib_valid) {
        float min_depth = d_sensor - span;
        float max_depth = d_sensor;
        const float eps = 0.001f;
        if (d1 < (min_depth - eps) || d1 > (max_depth + eps)) calib_valid = false;
        if (d2 < (min_depth - eps) || d2 > (max_depth + eps)) calib_valid = false;
      }

      if (calib_valid) {
        float t = (i - i1) / (i2 - i1);
        return d1 + t * (d2 - d1);
      }

      // Fallback: theoretical sensor curve (0..sensor span column above sensor)
      float h_over_sensor = id(sensor_column_filtered_m).state;
      if (isnan(h_over_sensor)) return NAN;
      return d_sensor - h_over_sensor;

  # 2.6b Published Depth Below Head (backward-compatible): simply expose raw depth
  - platform: template
    id: water_depth_from_head
    name: "Depth Below Head"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;  // Gate until single publish moment
      return id(well_depth_raw).state;

  # 2.6c Kalman-filtered Depth Below Head – tunes: process_std_dev (q^0.5), error (r^0.5)
  # Tuning quick guide:
  #   - process_std_dev (m per update): 0.02–0.10 typical, up to 0.30 for fast changes.
  #   - source error (m): 0.01–0.05 typical; start at 0.02.
  #   - Values are per update; if you change sensor_update_sec, re-tune for similar behavior.
  - platform: combination
    type: kalman
    id: water_depth_from_head_kalman
    name: "Depth Below Head (Kalman)"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    icon: "mdi:arrow-down"
    # Process noise std dev (m per update). Start with ~0.05 m; increase for faster response.
    process_std_dev: 0.05
    sources:
      # Measurement source noise std dev (m). Typical 0.01–0.05 m; start with 0.02 m (2 cm).
      - source: well_depth_raw
        error: 0.02

  # 2.7 Water depth below surface (m)
  - platform: template
    id: water_depth_from_surface
    name: "Depth Below Surface"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;          // m below well head
      float surface_to_head = id(cfg_surface_to_well_head).state;  // m (surface down to well head)

      if (isnan(depth_head) || isnan(surface_to_head)) {
        return NAN;
      }

      // Depth below surface = depth below head + head depth below surface
      float depth_from_surface = depth_head + surface_to_head;
      return depth_from_surface;

  # 2.7b Water depth below surface (Kalman)
  # Derived via template from head Kalman + surface offset (translation-invariant); no extra filter.
  - platform: template
    id: water_depth_from_surface_kalman
    name: "Depth Below Surface (Kalman)"
    icon: "mdi:arrow-down"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head_k = id(water_depth_from_head_kalman).state;   // m below well head (Kalman)
      float surface_to_head = id(cfg_surface_to_well_head).state;     // m (surface down to well head)
      if (isnan(depth_head_k) || isnan(surface_to_head)) {
        return NAN;
      }
      return depth_head_k + surface_to_head;

  # 2.8 Water height above pump 1 (m), positive = pump submerged
  - platform: template
    id: water_over_pump1
    name: "Over Pump 1"
    icon: "mdi:pump"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump1 = id(cfg_head_to_pump1).state;
      if (isnan(depth_head) || isnan(d_pump1)) return NAN;

      float height_over_pump = d_pump1 - depth_head;
      return height_over_pump;

  # 2.9 Water height above pump 2 (m)
  - platform: template
    id: water_over_pump2
    name: "Over Pump 2"
    icon: "mdi:pump"
    unit_of_measurement: "m"
    device_class: distance
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${sensor_update_sec}s
    filters:
      - lambda: |-
          if (isnan(x)) return {};
          return x;
    lambda: |-
      if (!id(publish_ready)) return NAN;
      float depth_head = id(water_depth_from_head).state;
      float d_pump2 = id(cfg_head_to_pump2).state;
      if (isnan(depth_head) || isnan(d_pump2)) return NAN;

      float height_over_pump = d_pump2 - depth_head;
      return height_over_pump;

# ============================================================
# 3) ERROR STATUS
# ============================================================

binary_sensor:
  - platform: template
    id: water_sensor_error
    name: "Sensor Error"
    device_class: problem
    entity_category: diagnostic
    lambda: |-
      if (!id(sensor_power).state) {
        // Sensor intentionally OFF → no error
        return false;
      }
      float u = id(shunt_voltage).state;
      if (isnan(u) || u < 0.05f || u > 3.2f) {
        return true;
      }
      return false;
    filters:
      - delayed_on: 10s
      - delayed_off: 10s
  - platform: template
    id: water_dry
    name: "Well Dry"
    device_class: problem
    entity_category: diagnostic
    lambda: |-
      // Simple dry detection: loop current below configured threshold.
      if (!id(publish_ready) || !id(sensor_power).state) return false;
      float i = id(loop_current_filtered).state;
      float threshold = id(cfg_dry_current_band_mA).state;
      if (isnan(i)) return false;
      if (isnan(threshold) || threshold <= 0.0f) threshold = 5.0f; // fallback default
      return i < threshold;
    filters:
      - delayed_on: 30s
      - delayed_off: 30s
